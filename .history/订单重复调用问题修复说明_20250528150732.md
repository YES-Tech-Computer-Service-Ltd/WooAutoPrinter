# 订单重复调用问题修复说明

## 问题分析

根据日志分析，发现以下重复调用问题：

1. **重复的API实例创建** - WooCommerceApiFactory每次都创建新实例
2. **重复的配置获取** - SettingsRepository被频繁调用获取配置
3. **重复的订单屏幕初始化** - OrdersScreen多次初始化
4. **重复的API请求** - 同时有多个相同的HTTP请求在执行
5. **重复的刷新操作** - ViewModel和Screen中多个地方触发刷新

## 修复方案

### 1. WooCommerceApiFactory缓存优化

- 添加了API实例缓存机制
- 相同配置时复用现有实例，避免重复创建
- 只有在配置变更时才创建新实例

**修改文件**: `WooCommerceApiFactory.kt`

```kotlin
// 添加缓存机制
private var cachedApi: WooCommerceApi? = null
private var cachedConfig: WooCommerceConfig? = null

// 检查配置是否相同，相同时复用实例
if (cachedApi != null && isSameConfig(cachedConfig!!, config)) {
    return cachedApi!!
}
```

### 2. OrderRepositoryImpl防重复调用机制

- 添加最小刷新间隔限制（2秒）
- 检查是否有正在进行的刷新任务
- 缓存API实例，避免重复获取配置

**修改文件**: `OrderRepositoryImpl.kt`

```kotlin
// 防重复调用机制
private var lastRefreshTime = 0L
private val minRefreshInterval = 2000L
private var cachedApiInstance: WooCommerceApi? = null

// 刷新前检查间隔和状态
if (currentTime - lastRefreshTime < minRefreshInterval) {
    return Result.success(cachedOrders)
}
```

### 3. OrdersViewModel优化

- 添加防重复调用机制
- 分离配置检查和订单刷新逻辑
- 优化刷新间隔控制

**修改文件**: `OrdersViewModel.kt`

```kotlin
// 防重复调用控制
private var isRefreshing = false
private var isCheckingConfig = false
private val minRefreshInterval = 2000L
private val minConfigCheckInterval = 3000L

// 刷新前检查状态
if (isRefreshing || (currentTime - lastRefreshTime < minRefreshInterval)) {
    return
}
```

### 4. OrdersScreen简化初始化

- 减少多个LaunchedEffect的重复操作
- 只在必要时触发刷新
- 避免导航时的不必要API调用

**修改文件**: `OrdersScreen.kt`

```kotlin
// 简化初始化逻辑
LaunchedEffect(key1 = Unit) {
    isInitialized.value = true
    // 只检查配置，不立即刷新
    val configResult = viewModel.checkApiConfiguration()
}

// 导航监听优化
if (orders.isEmpty() && !isLoading) {
    viewModel.refreshOrders()
}
```

## 优化效果

1. **减少API实例创建** - 相同配置时复用实例
2. **防止频繁刷新** - 2秒内的重复请求被忽略
3. **优化初始化流程** - 避免多个组件同时触发刷新
4. **提升性能** - 减少不必要的网络请求和对象创建
5. **改善用户体验** - 减少重复加载和卡顿

## 测试建议

1. 监控日志确认重复调用减少
2. 测试应用启动和页面切换时的API调用次数
3. 验证缓存机制是否正常工作
4. 确认订单数据刷新的及时性和准确性

## 注意事项

- 缓存机制需要在配置变更时正确清理
- 防重复机制的间隔时间可根据实际情况调整
- 需要确保在网络异常时的错误处理依然有效 