确实有两个“数据源”同时存在，这正是 active 页面与 history 页面显示不一致的根本原因：
History 页面
OrdersScreen 里用的是 OrdersViewModel.orders，它来自 OrderRepositoryImpl 的 _ordersFlow。这个 Flow 在 refreshOrders() 时直接使用 API 返回的 OrderDto.toOrder() 结果（内存缓存），因此：
order.woofoodInfo 就是 API 里完整的结构，deliveryTime 之类不会丢。
order.items 里也保留了 LineItemDto 解析出的 options（套餐/加料/备注），所以详情页能显示全部信息。
Active 页面
OrdersActivePlaceholderScreen 用的是 OrdersViewModel.newProcessingOrders / inProcessingOrders，这两个 Flow 来自 OrderDao.getNewProcessingOrders()，然后经过 OrderMapper.mapEntityToDomain() 转成领域模型。这里有两个重要差异：
mapEntityToDomain() 没有使用数据库里存的 woofoodInfo 字段，而是重新去 entity.customerNote 里猜预期时间、配送/自取等。可我们在 OrderDto.toOrder() 里已经把系统元数据清理掉，只留下用户备注（为了 UI 更纯净），所以这些“猜测”永远拿不到预期时间，自然与 history 版本不一致。
OrderLineItemEntity 这个表结构 只存了商品的 name/quantity/price，没有字段保存 ItemOption（加料、套餐明细）。因此凡是通过 DAO 读出来的订单，items.options 都是空的；Active 页面点击后的详情就缺了单个商品的备注/选项，而 history 页面因直接用内存缓存的 order.items，所以还能看到。
总结：active 与 history 点击出来的订单详情最终都走同一个 OrderDetailDialog，区别在于传进去的 order 数据【从 DB 读】还是【从内存缓存(=API原始结果)】。现在 DB 模型缺失 woofoodInfo、缺失 item options，所以 active 这条链路会“瘦身”很多。
接下来的修复方向就是：
修改 OrderMapper.mapEntityToDomain()：如果 entity.woofoodInfo 不为空，应直接转换为 WooFoodInfo 使用，只有字段缺失时才去 customerNote 里兜底。
扩充 OrderLineItemEntity，或者单独存储 ItemOption 列表，让 Room 能把商品选项/备注也落盘，再在 mapEntityToDomain() 中还原。这样 Active 列表出来的订单就和 history 一致了。
只要这两点同步好，active 页面点进详情会和 history 的数据完全一致。